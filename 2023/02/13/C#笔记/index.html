<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-SN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="第一天交互模式：C&#x2F;S:要求客户的电脑上必须要安装一个客户端：qq、360、快播等…..                  B&#x2F;S:要求客户的电脑上只需要安装一个浏览器。 解决方案、项目及类之间的关系：    解决方案：公司    项目：部门    类：员工    在视图里面找解决方案资源管理器 方法或者函数：Main函数是我们程序的主入口，你写的代码如果想要被执行的话，必须写">
<meta property="og:type" content="article">
<meta property="og:title" content="田和朱的小空间">
<meta property="og:url" content="https://longertian.github.io/2023/02/13/C#%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="田和朱的小空间">
<meta property="og:description" content="第一天交互模式：C&#x2F;S:要求客户的电脑上必须要安装一个客户端：qq、360、快播等…..                  B&#x2F;S:要求客户的电脑上只需要安装一个浏览器。 解决方案、项目及类之间的关系：    解决方案：公司    项目：部门    类：员工    在视图里面找解决方案资源管理器 方法或者函数：Main函数是我们程序的主入口，你写的代码如果想要被执行的话，必须写">
<meta property="og:locale" content="zh_SN">
<meta property="og:image" content="c:\Users\80741\AppData\Roaming\Typora\typora-user-images\image-20220804223043161.png">
<meta property="og:image" content="c:\Users\80741\AppData\Roaming\Typora\typora-user-images\image-20220809192125662.png">
<meta property="og:image" content="c:\Users\80741\AppData\Roaming\Typora\typora-user-images\image-20220809185430520.png">
<meta property="article:published_time" content="2023-02-13T12:08:20.966Z">
<meta property="article:modified_time" content="2023-02-13T12:15:28.640Z">
<meta property="article:author" content="龙Sir">
<meta property="article:tag" content="love | learn | live">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\80741\AppData\Roaming\Typora\typora-user-images\image-20220804223043161.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://longertian.github.io/2023/02/13/C#笔记/"/>





  <title> | 田和朱的小空间</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-SN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">田和朱的小空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">♥Everything is because of love♥</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://longertian.github.io/2023/02/13/C#%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="田和朱的小空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-02-13T20:08:20+08:00">
                2023-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><p>交互模式：C&#x2F;S:要求客户的电脑上必须要安装一个客户端：qq、360、快播等…..<br>                  B&#x2F;S:要求客户的电脑上只需要安装一个浏览器。</p>
<p>解决方案、项目及类之间的关系：<br>    解决方案：公司<br>    项目：部门<br>    类：员工<br>    在视图里面找解决方案资源管理器</p>
<p>方法或者函数：Main函数是我们程序的主入口，你写的代码如果想要被执行的话，必须写在Main函数当中。</p>
<p>.sln：解决方案文件，里面包含着整个解决方案的信息，可以双击运行。<br>.csproj：项目文件，里面包含着这个项目的信息，可以双击运行。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;要打印的内容&quot;</span>);</span><br><span class="line">Console.ReadKey();<span class="comment">//暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在我们的控制台当中</span></span><br></pre></td></tr></table></figure>

<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>——单行注释 &#x2F;&#x2F;<br>多行注释 &#x2F;<em>要注释的内容</em>&#x2F;<br>文档注释 &#x2F;&#x2F;&#x2F; 多用来解释类或者方法</p>
<p>数据类型：<br>1、整数类型：int  只能存储整数，不能存储小数。<br>2、小数类型：double 既能存储整数，也能存储小数，小数点后面的位数 15~16位。<br>3、金钱类型：decimal：用来存储金钱，值后面需要加上一个m.<br>4、字符串类型:string,用来存储多个文本，也可以存储空，字符串类型的值需要被 双引号引来，这个双引号必须是英文半角状态下的双引号<br>5、字符类型：char,用来存储单个字符，最多、最少只能有一个字符，不能存储空。字符类型的值需要用 单引号因起来。英文半角状态下的单引号。</p>
<p>波浪线：<br>1、如果你的代码中出现了红色的波浪线，意味着你的代码中出现了语法错误。<br>2、如果你的代码中出现了绿色的波浪线，说明你的代码语法并没有错误，只不过提示你有可能会出现错误，但是不一定会出现错误。（警告线）</p>
<h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>类型如果相兼容的两个变量，可以使用自动类型转换或者强制类型转换，但是，如果两个类型的变量不兼容，比如 string与int或者string 与double，这个时候我们可以使用一个叫做Convert的转换工厂进行转换。<br>注意：使用Convert进行类型转换，也需要满足一个条件：面儿上必须要过的去（确实能转换）。</p>
<p>顺序结构：程序从Main函数进入，从上到下一行一行的执行，不会落下任何一行。<br>分支结构：if  if-else<br>选择结构：if else-if switch-case<br>循环结构：while do-while for foreach</p>
<p>if语句：<br>语法：<br>if(判断条件)<br>{<br>    要执行的代码;<br>}<br>判断条件：一般为关系表达式或者bool类型的值。<br>执行过程：程序运行到if处，首先判断if所带的小括号中的判断条件，<br>如果条件成立，也就是返回true，则执行if所带的大括号中的代码，<br>如果判断条件不成立，也就是返回一个false。则跳过if结构，继续向下执行。</p>
<p>if结构的特点：先判断，再执行，有可能一行代码都不执行<br>用于一种情况的判断。</p>
<p>if-else<br>语法：<br>if(判断条件)<br>{<br>    执行的代码;<br>}<br>else<br>{<br>    执行的代码<br>}<br>执行过程：程序执行到if处，首先判断if所带的小括号中的判断条件是否成立，如果成立，也就是返回一个true，则执行if所带的大括号中的代码，执行完成后，跳出if-else结构。如果if所带的小括号中的判断条件不成立，也就是返回一个false，则跳过if语句，执行else所带的大括号中的语句，执行完成后，跳出if-else结构。</p>
<p>if-else特点：先判断，再执行，最少都要执行一条代码。用于两种情况的判断。</p>
<p>注意：else永远跟离它最近的那个if配对。</p>
<p>if else-if<br>作用：用来处理多条件的区间性的判断。<br>语法：<br>if(判断条件)<br>{<br>    要执行的代码;<br>}<br>else if(判断条件)<br>{<br>    要执行的代码;<br>}<br>else if(判断条件)<br>{<br>    要执行的代码;<br>}<br>……..<br>else<br>{<br>    要执行的代码;<br>}<br>执行过程；程序首先判断第一个if所带的小括号中的判断条件，如果条件成立，也就是返回一个true，则执行该if所带的大括号中的代码，执行完成后，立即跳出if else-if结构。如果第一个if所带的判断条件不成立也就是返回一个false，则继续向下进行判断，依次的判断每一个if所带的判断条件，如果成立，就执行该if所带的大括号中的代码，如果不成立，则继续向下判断，如果每个if所带的判断条件都不成立，就看当前这个if else-if结构中是否存在else。如果有else的话，则执行else中所带的代码，如果没有else，则整个 if-else if什么都不做。else可以省略。</p>
<h1 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h1><p>异常捕获：程序中会经常出现各种各样的异常，应该经常使用try-catch来进行异常捕获。<br>哪行代码有可能出现异常，就踹他一脚：<br>语法：<br>try<br>{<br>    有可能出现异常的代码;<br>}<br>catch<br>{<br>    出现异常后需要执行的代码;<br>}<br>执行过程：如果try中的代码没有出现异常，则catch中的代码不会执行；如果try中的代码出现异常，哪怕其中还有很多代码没有执行，都会直接跳转到catch中执行。</p>
<p>注意：try和catch之间不能有任何代码。</p>
<p>switch–case<br>用来处理多条件的定值的判断。<br>语法：<br>switch(变量或者表达式的值)<br>{<br>    case 值1：要执行的代码；<br>    break；<br>    case 值2：要执行的代码；<br>    break；<br>    case 值3：要执行的代码；<br>    break；<br>    …………<br>    default:要执行的代码；<br>    break；<br>}<br>执行过程：程序执行到switch处，首先将括号中变量或者表达式的值计算出来，然后跟每一个case的值进行匹配；一旦匹配成功，就执行该case所带的代码，执行完成之后，遇到break，跳出switch–case结构。如果跟每个case都不匹配，则执行default后面的语句，如果没有default语句则直接跳出switch–case结构。</p>
<p>while循环：<br>while(循环条件):<br>{<br>    循环体;<br>}</p>
<p>最简单最常用的死循环：<br>while(1):<br>{<br>}</p>
<p>break关键字的用法：<br>1、可以跳出switch–case结构；<br>2、可以跳出当前所在的while循环；<br>break一般不单独出现，经常跟if同时出现。</p>
<p>do–while循环：<br>do<br>{<br>    (循环体);<br>}while(循环条件);<br>执行过程：程序首先会执行do中的循环体，执行完成后，去判断do–while循环的条件，如果成立，则继续执行do中的循环体，否则跳出循环。<br>特点：先循环，后判断至少执行一次循环体。</p>
<h1 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h1><p>for循环：<br>语法：<br>for(表达式1;表达式2;表达式3)<br>{<br>    循环体;<br>}<br>表达式1一般为声明循环变量，记录循环的次数(int i&#x3D;0;)<br>表达式2一般为循环条件(i&lt;10)<br>表达式3一般为改变循环条件的代码，使循环条件终有一天不再成立(i++)。<br>执行过程：程序首先执行表达式1，声明了一个循环变量用来记录循环的次数，然后执行表达式2，判断循环条件是否成立，如果表达式2返回的结果为true，则执行循环体。当执行完循环体后，执行表达式3，然后执行表达式2继续判断循环条件是否成立，如果成立则继续执行循环体，如果不成立，则跳出for循环。</p>
<p>int.TryParse：尝试着将一个字符串转换成int类型。（TryParse是一个方法&#x2F;函数）</p>
<p>程序调试：<br>1、写完一段程序后，想看一下这段程序的执行过程。<br>2、当你写完这段程序后，发现，程序并没有按照你想象的样子去执行。</p>
<p>调试方法：<br>1、F11逐语句调试(单步调试)<br>2、F10逐过程调试<br>3、断点调试</p>
<p>三元表达式：<br>语法：<br>表达式1?表达式2:表达式3;<br>表达式1一般为一个关系表达式。<br>如果表达式1的值为true，那么表达式2的值就是整个三元表达式的值。<br>如果表达式1的值为false，那么表达式3的值就是整个三元表达式的值。<br>注意：表达式2的结果类型必须跟表达式3的结果类型一致，并且也要跟整个三元表达式的结果类型一致。</p>
<h1 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h1><p>常量：（常量不能够被重新赋值）<br>声明的常量的语法：<br>const 变量类型 变量名&#x3D;值</p>
<p>枚举：<br>语法：<br>[public] enum 枚举名<br>{<br>    值1,<br>    值2,<br>    值3,<br>    ……..（最后一个值的逗号可以加可以不加）<br>}<br>public:访问修饰符。公开的公共的，哪都可以访问。<br>enum：关键字，声明枚举的关键字<br>枚举名：要符合Pascal命名规范</p>
<p>将枚举声明到命名空间的下面，类的外面，表示这个命名空间下，所有的类都可以使用这个枚举。</p>
<p>枚举就是一个变量类型。只是枚举声明、赋值、使用的方式跟那些普通的变量类型不一样。</p>
<p>我们可以将一个枚举类型的变量跟int类型和string类型互相转换。</p>
<p>枚举类型默认是跟int类型相互兼容的，所以可以通过强制类型转换的语法互相转换。当转换一个枚举中没有的值的时候，不会抛异常，而是直接将数字显示出来。</p>
<p>枚举同样也可以跟string类型互相转换，如果将枚举类型转换成string类型，则直接调用ToString().</p>
<p>如果将字符串转换成枚举类型则需要下面这样一行代码：</p>
<p><code>(要转换的枚举类型)Enum.Parse(typeof(要转换的枚举类型),&quot;要转换的字符串&quot;)</code></p>
<p>如果转换的字符串是数字，则就算枚举中没有，也不会抛异常。如果转换的字符串是文本，如果枚举中没有，则会抛出异常。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> QQState</span><br><span class="line">    &#123;</span><br><span class="line">        OnLine=<span class="number">1</span>,</span><br><span class="line">        OffLine,</span><br><span class="line">        Leave,</span><br><span class="line">        Busy,</span><br><span class="line">        QMe</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请选择您的qq在线状态 1--OnLine 2--OffLine 3--Leave 4--Busy 5--QMe&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> input = Console.ReadLine();</span><br><span class="line">            <span class="keyword">switch</span> (input)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    QQState s1 = (QQState)Enum.Parse(<span class="keyword">typeof</span>(QQState), input);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;您选择的在线状态是&#123;0&#125;&quot;</span>, s1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    QQState s2 = (QQState)Enum.Parse(<span class="keyword">typeof</span>(QQState), input);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;您选择的在线状态是&#123;0&#125;&quot;</span>, s2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    QQState s3 = (QQState)Enum.Parse(<span class="keyword">typeof</span>(QQState), input);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;您选择的在线状态是&#123;0&#125;&quot;</span>, s3);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    QQState s4 = (QQState)Enum.Parse(<span class="keyword">typeof</span>(QQState), input);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;您选择的在线状态是&#123;0&#125;&quot;</span>, s4);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                    QQState s5 = (QQState)Enum.Parse(<span class="keyword">typeof</span>(QQState), input);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;您选择的在线状态是&#123;0&#125;&quot;</span>, s5);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br></pre></td></tr></table></figure>

<p>结构：<br>可以帮助我们一次性声明多个不同类型的变量。<br>语法：<br>[public] struct 结构名<br>{<br>    成员;&#x2F;&#x2F;字段，（字段与变量的区别就是，字段可以存储多个值，而变量只能存储一个值；规范上讲要给每个字段前面加上一个下划线）<br>}<br>变量在程序运行期间只能存储一个值，而字段可以存储多个值。</p>
<p>结构能够一次性生成多个不同类型的变量，减少变量的使用。</p>
<p>数组：<br>一次性存储多个相同类型的变量。<br>语法：<br>数组类型[] 数组名&#x3D;new 数组类型[数组长度];</p>
<p>***数组的长度一旦固定了，就不能再被改变了</p>
<p>数组类型[] 数组名&#x3D;{值，值，……};		这种声明方式在声明的同时给数组赋值了。</p>
<p>数组类型[] 数组名&#x3D;new 数组类型[数组长度]{值，值，……};		后面值的长度需要与声明的长度一致。</p>
<p>数组类型[] 数组名&#x3D;new 数组类型[]{值，值，……};</p>
<p>冒泡排序：就是将一个数组中的元素按照从大到小或者从小到大的顺序进行排列。<br>int[] nums&#x3D;{9,8,7,6,5,4,3,2,1,0}; 0 1 2 3 4 5 6 7 8 9<br>第一趟比较：8 7 6 5 4 3 2 1 0 9 交换了9次     i&#x3D;0  j&#x3D;nums.Length-1-i<br>第二趟比较：7 6 5 4 3 2 1 0 8 9 交换了8次     i&#x3D;1  j&#x3D;nums.Length-1-i<br>第三趟比较：6 5 4 3 2 1 0 7 8 9 交换了7次     i&#x3D;2  j&#x3D;nums.Length-1-i<br>第四趟比较：5 4 3 2 1 0 6 7 8 9 交换了6次     i&#x3D;3  j&#x3D;nums.Length-1-i<br>第五趟比较：4 3 2 1 0 5 6 7 8 9 交换了5次<br>第六趟比较：3 2 1 0 4 5 6 7 8 9 交换了4次<br>第七趟比较：2 1 0 3 4 5 6 7 8 9 交换了3次<br>第八趟比较：1 0 2 3 4 5 6 7 8 9 交换了2次<br>第九趟比较：0 1 2 3 4 5 6 7 8 9 交换了1次<br>for(int i&#x3D;0;i&lt;number.Length-1;i++)<br>{<br>    for(int j&#x3D;0;j&lt;nums.Length-1-i;j++)<br>    {<br>        if(nums[j]&gt;nums[j+1])<br>        {<br>            int temp&#x3D;nums[j];<br>            nums[j]&#x3D;nums[j+1];<br>            nums[j+1]&#x3D;temp;<br>        }<br>    }<br>}</p>
<p>方法：<br>函数就是将一堆代码进行重用的一种机制。方法是写在类里面的（class）<br>函数的语法：<br>[public] static 返回值类型 方法名([参数列表])<br>{<br>    方法体；<br>}<br>public：访问修饰符，公开的，公共的，哪都可以访问。<br>static：静态的<br>返回值类型：如果不需要写返回值，写void<br>方法名：Pascal 每个单词的首字母都大些。其余字母小写<br>参数列表：完成这个方法所必须要提供给这个方法的条件。如果没有参数，小括号也不能省略。</p>
<p>方法写好后，如果想要被执行，必须要在Main()函数中调用。<br>方法的调用语法：<br>类名.方法名([参数])；<br>***在某些情况下，类名是可以省略的，如果你写的方法跟Main()函数同在一个类中，这个时候，类名可以省略。</p>
<p>return：<br>1、在方法中返回要返回的值。<br>2、立即结束本次方法</p>
<h1 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h1><p>我们在Main()函数中，调用Test()函数，我们管Main()函数称之为调用者，管Test()函数称之为被调用者。如果被调用者想要得到调用者的值：<br>1、传递参数。<br>2、使用静态字段来模拟全局变量。（C#中没有全局变量这个东西；静态字段放在类中；通过静态字段，不用传递参数也能访问到）<br>如果调用者想要得到被调用者的值：返回值（return）</p>
<p>不管是实参还是形参，都是在内存中开辟了空间的。</p>
<p>方法的功能一定要单一。<br>GetMax(int n1,int n2)<br>方法中最忌讳的就是出现提示用户输入的字眼。实在没办法避免就用。（第一次接受尽量在main函数中）</p>
<p>out、ref、params<br>out参数：<br>如果你在一个方法中，返回多个相同类型的值的时候，可以考虑返回一个数组。<br>但是，如果返回多个不同类型的值的时候，返回数组就不行了，那么这个时候，<br>我们可以考虑使用out参数。<br>out参数就侧重于在一个方法中可以返回多个不同类型的值。out在方法外可以不赋值。</p>
<p>ref参数：<br>能够将一个变量带入一个方法中进行改变，改变完成后，再将改变后的值带出方法。<br>ref参数要求在方法外必须为其赋值，而方法内可以不赋值。</p>
<p>params可变参数：<br>将实参列表中跟可变参数数组类型一致的元素都当做数组的元素去处理。<br>params可变参数必须是形参列表中的最后一个元素。</p>
<p>方法的重载：方法的重载指的就是方法的名称相同给，但是参数不同。<br>参数不同，分为两种情况<br>1)、如果参数的个数相同，那么参数的类型就不能相同。<br>2)、如果参数的类型相同，那么参数的个数就不能相同。<br>方法的重载跟返回值没有关系。</p>
<p>方法的递归：方法自己调用自己。</p>
<h1 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h1><p>飞行棋项目</p>
<h1 id="第九天（面向对象）"><a href="#第九天（面向对象）" class="headerlink" title="第九天（面向对象）"></a>第九天（面向对象）</h1><p><strong>面向对象：意在写出一个通用的代码，屏蔽差异。</strong></p>
<p>关门<br>面向过程：关门<br>张三 一脚把门踹紧了<br>李四 轻轻的把门带上了<br>王五 门没关严，留了个尾巴</p>
<p>面向对象：关门<br><strong>门可以被关闭</strong></p>
<p><strong>对象必须是看得见摸得着的</strong></p>
<p>我们把这些具有相同属性和相同方法的对象进行进一步的封装，抽象出来<strong>类</strong>这个概念。<br>类就是个模子，确定了对象应该具有的属性和方法。<br>对象是根据类创建出来的。<br>类就是一个盖大楼的图纸，对象就是盖出来的大楼。</p>
<p><strong>类</strong><br>语法：<br>[public] class 类名<br>{<br>    字段;<br>    属性;<br>    方法;<br>}</p>
<p>写好了一个类之后，我们需要创建这个类的对象，我们管创建这个类的对象过程称之为<strong>类的实例化</strong>。使用关键字 new.</p>
<p>this：表示当前这个类的对象。</p>
<p>类是不占内存的，而对象是占内存的。</p>
<p><strong>属性</strong><br>属性的作用就是保护字段、对字段的赋值和取值进行限定。<br>属性的本质就是两个方法，一个叫**get()<strong>一个叫</strong>set()**。Ctrl+r+e快速生成这两个方法。</p>
<p>既有get()也有set()我们诚之为可读可写属性。<br>只有get()没有set()我们称之为只读属性<br>没有get()只有set()我们称之为只写属性</p>
<p>给属性赋值的时候，首先会执行set()方法</p>
<p>输出属性的值时候，首先会执行get()方法</p>
<p>给属性赋值，值会传给字段，这就是上述两个为什么称之为方法。</p>
<p>Field字段<br>Method方法<br>Property属性</p>
<p>****字段就是女人  属性才是男人。		属性对外</p>
<p>所以把字段设置为private，字段必须是私有的；属性设置为public，属性一定要设置为公开的。</p>
<p><strong>访问修饰符</strong><br>public：公开的公共的，在哪都能访问。<br>private：私有的，只能在当前类的内部进行访问，出了这个类就访问不到了（默认）</p>
<p><strong>对象的初始化</strong></p>
<p>当我们创建好一个类的对象后，需要给这个对象的每个属性去赋值。我们管这个过程称之为对象的初始化。</p>
<p><strong>静态和非静态的区别</strong><br>1、在非静态类中，既可以有实例成员，也可以有静态成员。<br>2、在调用实例成员的时候，需要使用对象名.实例成员;<br>      在调用静态成员的时候，需要使用类名.静态成员名;<br>总结：静态成员必须使用类名去调用，而实例成员使用对象名调用。<br>           静态函数中，只能访问静态成员，不允许访问实例成员。<br>           实例函数中，既可以使用静态成员，也可以使用实例成员。<br>           静态类中只允许有静态成员，不允许出现实例成员。静态类不允许创建对象，因为静态类的调用使用类名调用的</p>
<p>使用：<br>1、如果你想要你的类当做一个”工具类”去使用，这个时候可以考虑将类写成静态的。这样就不需要先实例化再调用；<br>2、静态类在整个项目中资源共享。只有在程序全部结束之后，静态类才会释放资源。</p>
<p>释放资源。GC——Garbage Collection垃圾回收器</p>
<p><strong>构造函数</strong><br>作用：帮助我们初始化对象(给对象的每个属性依次的赋值)<br>构造函数是一个特殊的方法：<br>1、构造函数没有返回值，连void也不能写。<br>2、构造函数的名称必须跟类名一样。</p>
<p>创建对象的时候会执行构造函数，然后再执行初始化对象的后续代码。</p>
<p>构造函数是可以有重载的。<br>***类当中会有一个默认的无参数的构造函数，当你写一个新的构造函数之后，不管是有参数的还是无参数的，那个默认的无参数的构造函数都被干掉了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age,<span class="built_in">char</span> gender,<span class="built_in">int</span> chinese,<span class="built_in">int</span> english </span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Name = name;</span><br><span class="line">            <span class="keyword">this</span>.Age = age;</span><br><span class="line">            <span class="keyword">this</span>.Gender = gender;</span><br><span class="line">            <span class="keyword">this</span>.Chinese = chinese;</span><br><span class="line">            <span class="keyword">this</span>.English = english;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p><strong>new关键字</strong><br><code>Person zsPerson = new Person();</code><br>new帮助我们做了3件事儿：<br>1、在内存中开辟一块空间<br>2、在开辟的空间中创建对象<br>3、调用对象的构造函数进行初始化对象</p>
<p><strong>this关键字</strong><br>1、代表当前类的对象<br>2、在类当中显示的调用本类的构造函数  		<code>:this()</code>   ()里面需要的参数传入变量名，不需要的参数传入默认值</p>
<p><strong>析构函数</strong></p>
<p>当程序结束的时候，才会调用析构函数。它的作用就是帮助我们释放资源，资源会立刻被释放。不使用析构函数会有GC帮助我们自动释放资源。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~类名()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h1><p><strong>命名空间</strong><br>可以认为类是属于命名空间的。<br>如果在当前项目中没有这个类的命名空间，需要我们手动的导入这个类所在的命名空间。<br>1、用鼠标去点<br>2、alt+shift+F10<br>3、记住命名空间，手动的去引用</p>
<p>在一个项目中引用另一个项目的类<br>第一步：添加引用<br>第二步：引用命名空间</p>
<p><strong>值类型和引用类型</strong><br>区别：<br>1、值类型和引用类型在内存上存储的地方不一样。<br>2、在传递值类型和传递引用类型的时候，传递的方式不一样。<br>值类型我们称之为值传递，引用类型我们称之为引用传递。<br>我们学的值类型和引用类型：<br>值类型：int、double、bool、char、decimal、struct、enum<br>引用类型：string、自定义类、数组<br>存储：<br>值类型的值是存储在内存的栈当中。<br>引用类型的值是存储在内存的堆中。</p>
<p><strong>字符串</strong><br>1、字符串的不可变性<br>当你给一个字符串重新赋值之后，老值并没有销毁，而是重新开辟一块空间存储新值。</p>
<p>当程序结束后，GC扫描整个内存，如果发现有的空间没有被指向，则立即把它销毁。</p>
<p>2、我们可以讲字符串看做是char类型的一个只读数组。<br>ToCharArray();将字符串转换为char数组<br>new string(char[] chs):能够将char数组转换为字符串</p>
<p><strong>字符串提供的各种方法</strong><br>1、Length：获得当前字符串中字符的个数<br>2、ToUpper():将字符转换成大写形式<br>3、ToLower():将字符串转换成小写形式<br>4、Equals(lessonTwo,StringComparison.OrdinalIgnoreCase):比较两个字符串，可以忽略大小写<br>5、Split()：分割字符串，返回字符串类型的数组。<br>6、Substring(索引)：截取字符串。在截取的时候包含要截取的那个位置。<br>7、IndexOf():判断某个字符串在字符串中第一次出现的位置，如果没有返回-1、值类型和引用类型在内存上存储的地方不一样。<br>8、LastIndexOf()：判断某个字符串在字符串中最后一次出现的位置，如果没有同样返回-1<br>9、StartsWith():判断以….开始<br>10、EndsWith():判断以…结束<br>11、Replace(“旧字符串”,”新字符串”):将字符串中某个字符串替换成一个新的字符串<br>12、Contains():判断某个字符串是否包含指定的字符串<br>13、Trim():去掉字符串中前后的空格<br>14、TrimEnd()：去掉字符串中结尾的空格<br>15、TrimStart()：去掉字符串中前面的空格<br>16、string.IsNullOrEmpty():判断一个字符串是否为空或者为null<br>17、string.Join()：将数组按照指定的字符串连接，返回一个字符串。</p>
<p><strong>继承</strong><br>我们可能会在一些类中，写一些重复的成员，我们可以将这些重复的成员，<br>单独的封装到一个类中，作为这些类的父类。<br>Student、Teacher、Driver  子类  派生类<br>Person   				  父类  基类<br>问题：子类继承了父类，那么子类从父类那里继承过来了什么？<br>答：子类继承了父类的属性和方法，但是子类并没有继承父类的私有字段。<br>问题：子类有没有继承父类的构造函数？<br>答：子类并没有继承父类的构造函数，但是。子类会默认的调用父类无参数的构造函数，创建父类对象，让子类可以使用父类中的成员。所以，如果在父类中重新写了一个有参数的构造函数之后，那个无参数的就被干掉了，子类就调用不到了，所以子类会报错。<br>解决办法：<br>1)、在父类中重新写一个无参数的构造函数。<br>2)、在子类中显示的调用父类的构造函数，使用关键字:base()</p>
<p>继承的特性<br>1、继承的单根性：一个子类只能有一个父类。<br>2、继承的传递性</p>
<p>object是所有类的基类。</p>
<p>new关键字<br>1)、创建对象<br>2)、隐藏从父类那里继承过来的同名成员。子类写和父类一样的方法名的时候，加上new关键字会主动影藏父类的同名方法。<br>隐藏的后果就是子类调用不到父类的成员。</p>
<h1 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h1><p><strong>里氏转换</strong>(特别重要)<br>1、子类可以赋值给父类。如果某个地方需要一个父类作参数，我们可以给一个子类来替代父类。<br>2、如果父类中装的是子类对象，那么可以将这个父类强转为子类对象。<br><code>Student ss = (student)p; </code></p>
<p>注：子类对象可以调用父类中的成员，但是父类对象永远都只能调用自己的成员。</p>
<p>is：表示类型转换，如果能够转换成功，则返回一个true，否则返回一个false<br><code>if(p is student) &#123;&#125;</code></p>
<p>as：表示类型转换，如果能够转换则返回对应的对象，否则返回一个null<br><code>Teacher t = p as Teacher;</code></p>
<p><strong>protected</strong>受保护的：可以在当前类的内部以及该类的子类中访问。</p>
<p><strong>ArrayList集合</strong></p>
<p><code>ArrayList List = new AreayList();</code></p>
<p>ArrayList集合的好处：长度可以任意改变，类型随便且不需要表明。</p>
<p>ArrayList集合的长度问题：<br>每次集合中实际包含的元素个数(count)超过了可以包含的元素的个数(capcity)的时候，集合就会向内存中申请多开辟一倍的空间，来保证集合的长度一直够用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list.Add() 	添加单个元素，也可以添加数组/集合，但是输出的时候默认打印为命名空间，需要判断类型后进行强制转换后输出。</span><br><span class="line">list.AddRange 添加集合元素，比如对象/数组等，不需要判断加强制转换，直接输出打印。</span><br><span class="line">list.Clear() 清除集合的所有元素。</span><br><span class="line">list.Remove() 删除集合中的指定元素。</span><br><span class="line">list.RemoveAt() 根据下标删除元素</span><br><span class="line">list.RemoveRange() 根据下表删除指定范围的元素。</span><br><span class="line">list.Sort() 可以顺序输出的时候按照从小到大输出。</span><br><span class="line">list.Reserve() 翻转输出。</span><br><span class="line">list.Insert(索引,？) 在指定位置插入元素。</span><br><span class="line">list.count 表示这个集合中实际包含的元素的个数</span><br><span class="line">list.capcity 表示这个集合可以包含的元素的个数	</span><br></pre></td></tr></table></figure>

<p><strong>List泛型集合</strong></p>
<p>创建泛型集合：<code>List&lt;int&gt; list = new List&lt;int&gt;();</code></p>
<p><strong>Hastable</strong> 键值对集合  类似于字典</p>
<p><code>Hashtable ht = new Hashtable();</code></p>
<p>在键值对集合当中，我们是根据键去找值的。<br>在集合中新增键值对：1、<code>ht.Add(键,值);</code>	2、<code>ht[键] = &quot;值&quot;;</code>，但是这个更倾向于重新赋值，若原来字典中已经存在了那个键值对，则会对键重新赋值。<br><code>ht.Remove(); </code>根据键去移除<br>键值对对——[键]&#x3D;值；<br>键和值的类型都是object；<br>var : 能够根据值推断出来类型；<br>使用var定义新的变量的时候，就必须给变量赋值，即使用<code>var input = &quot;张三&quot;</code><br>键值对集合当中，键必须是唯一的，而值是可以重复的</p>
<p><strong>foreach</strong>循环：用来循环遍历键值对</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>( <span class="keyword">var</span> item <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Path：<br><code>Path.GetFileName();</code> 获得文件名（包含扩展名）<br><code>Path.GetFileNameWithoutExtension();</code>获得文件名（不包含扩展名）<br><code>Path.Extension;</code> 获得文件扩展名<br><code>Path.GetDirectionName();</code> 获得文件路径（不包括文件名）<br><code>Path.GetFullPath();</code> 获得文件全路径</p>
<p>File：<br><code>File.Create(@&quot;全路径+所需新建的文件名&quot;); </code>新建文件<br><code>File.Delect(@&quot;全路径&quot;); </code>删除文件</p>
<p><code>File.ReadAllLines();按行读取文件，括号内是文件地址，解码格式</code></p>
<p><code>File.ReadAllText();按行读取文件（只能是文本文件），括号内是文件地址，解码格式</code></p>
<p>解码：<code>String str = Encoding.Default.GetString(buffer)</code> </p>
<p>编码：<code>byte[] buffer = Encoding.Default.GetBytes(str)</code></p>
<h1 id="第十二天"><a href="#第十二天" class="headerlink" title="第十二天"></a>第十二天</h1><p><strong>绝对路径和相对路径</strong><br>绝对路径：通过给定的这个路径直接能在我的电脑中找到这个文件。<br>相对路径：文件相对于应用程序的路径。<br>结论：我们在开发中应该去尽量的使用相对路径。</p>
<p><strong>装箱、拆箱</strong><br>装箱：就是将值类型转换为引用类型。<br>拆箱：将引用类型转换为值类型。<br>看两种类型是否发生了装箱或者拆箱，要看，这两种类型是否存在继承关系。</p>
<p>尽量避免，装箱和拆箱也会浪费时间</p>
<p><strong>字典：Dictionary</strong><br><code>Dictionary&lt;int,string&gt; dic = new Dictionary&lt;int,string&gt;();</code>键和值都需要确定类型，这是与Hashtable不一样的地方。<br><code>foreach (KeyValuePair&lt;int,string&gt;……)&#123;&#125; </code>通过这个可以匹配键值对。</p>
<p>文件流读取文件：<br>FileStream    操作字节<br>创建FileStream对象；new一个 ，然后后面会有很多参数<br>数据流操作完成滞后，需要手动释放资源<br>1、关闭流，fsRead.close();<br>2、释放流所占用的资源：fsRead.Dispose();</p>
<p>将创建文件流对象的过程写在using当中，会自动的帮助我们释放流所占用的资源。<br>using(new一个对象)<br>{</p>
<p>}</p>
<p><img src="C:\Users\80741\AppData\Roaming\Typora\typora-user-images\image-20220804223043161.png" alt="image-20220804223043161"></p>
<p><strong>多态</strong>：多态就是能让一个对象表现出多种类型<br>实现多态的手段：<br>1)、虚方法<br>步骤：首先将父类的方法标记为虚方法 ，使用关键字 virtual，这个函数可以被子类重新写一个遍。在子类方法前面加上override关键字。</p>
<p>2)、抽象类<br>当父类中的方法不知道如何去实现的时候，可以考虑将父类写成抽象类，将方法写成抽象方法。<br>比如，有猫、狗两个对象，则找一个抽象的动物类。</p>
<p>用关键字abstract来标记抽象类<br>用关键字abstract来标记抽象方法，抽象方法是不允许有方法体的。抽象方法存在的意义就是让子类来调用。</p>
<p>抽象类是不允许创建对象的，接口也是不允许创建对象的。</p>
<p>抽象类的实体化使用子类对象进行实体化。</p>
<p><strong>抽象类特点</strong></p>
<p>1.抽象成员必须标记为abstract,并且不能有任何实现。</p>
<p>2.抽象成员必须在抽象类中。</p>
<p>3.抽象类不能被实例化</p>
<p>4.子类继承抽象类后，必须把父类中的所有抽象成员都重写。（除非子类也是一个抽象类，则可以不重写）</p>
<p>5.抽象成员的访问修饰符不能是private</p>
<p>6.在抽象类中可以包含实例成员。并且抽象类的实例成员可以不被子类实现（抽象类既可以有抽象成员也可以有非抽象成员。非抽象成员不能够被抽象类所调用，但是可以被抽象类的子类所调用，这就是抽象类的非抽象成员的存在的意义。）</p>
<p>7.抽象类是有构造函数的。虽然不能被实例化。</p>
<p>8.如果父类的抽象方法中有参数，那么。继承这个抽象父类的子类在重写父类的方法的时候必须传入对应的参数。如果抽象父类的抽象方法中有返回值，那么子类在重写这个抽象方法的时候 也必须要传入返回值。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;使用虚方法和抽象类的选择：<br>如果父类中的方法有默认的实现，并且父类需要被实例化，这时可以考虑将父类定义成一个普通类，用虚方法来实现多态。</p>
<p>如果父类中的方法没有默认实现，父类也不需要被实例化，则可以将该类定义为抽象类。</p>
<h1 id="第十三天"><a href="#第十三天" class="headerlink" title="第十三天"></a>第十三天</h1><p><strong>c#中的访问修饰符</strong><br>public :公开的、公共的<br>private：私有的，只能在当前类的内部访问<br>protected：受保护的，只能在当前类的内部以及该类的子类中访问。<br>internal：只能在当前项目中访问。在同一个项目中，internal和public的权限是一样。<br>protected internal：protected+internal，在当前项目中的当前类的内部以及该类的子类中访问（意思就是该受保护的不能够跨项目传递了）</p>
<p>1、能够修饰类的访问修饰符只有两个：public、internal。<br>2、可访问性不一致。<br>子类的访问权限不能高于父类的访问权限，会暴露父类的成员。</p>
<p><strong>设计模式</strong><br>设计这个项目的一种方式。</p>
<p>可以看CSDN上面的23中设计模式。</p>
<p><strong>简单工厂设计模式</strong><br>简单工厂的核心，根据用户的输入创建对象赋值给父类</p>
<p>值类型：int double char decimal bool enum struct<br>引用类型：string 数组 自定义类 集合 object 接口<br>值类型的值存储在栈上，而引用类型的值存储在堆上。<br>值类型在复制的时候，传递的是这个值得本身。<br>引用类型在复制的时候，传递的是对这个对象的引用，即传递的是地址。可以理解为他们指向了同一个对象，即同一个new Person。（字符串特殊，因为字符串的不可变性！！！）</p>
<p>ref关键字就是把值传递变成了引用传递</p>
<p>序列化：就是将对象转换为二进制<br>反序列化：就是将二进制转换为对象<br>作用：传输数据。<br>序列化步骤：<br>第一步：将这个类标记为可以被序列化的。在类的上方增加一行代码：<code>[Serializable]</code>;<br>第二步：将对象转换为二进制</p>
<p>开始序列化对象：<br>using(FileStream fsWrite……代码)<br>{<code>BinaryFormatter bf = new BinaryFormatter();</code><br>bf &#x3D; Serializable(fsWrite,new Person p)<br>}  </p>
<p>反序列化就是 Deserialize</p>
<p><strong>partial</strong>部分类<br>再类前面增加一个partial就可以实现部分类，从而使得这个类被分为几个部分，即使用同名 partial class不会出现错误。<br><strong>sealed</strong>密封类<br>在类的前面增加关键字sealed，不能够被其他类继承，但是可以继承于其他类。</p>
<p><strong>接口</strong><br>声明接口的关键字是 interface</p>
<p>[public] interface I..able（接口名一般这么表示）<br>{<br>    成员;<br>}</p>
<p><strong>接口的特点</strong></p>
<p>接口可以有返回值<br>但是不能够有访问修饰符，默认为public<br>接口成员没有方法体<br>接口中不能够写字段，只能够写属性(自动属性)和方法<br>自动属性在编译的同时会自动生成一个字段，自动属性不允许写方法体，故不能进行属性限制了</p>
<p>接口是一种规范。<br>只要一个类继承了一个接口，这个类就<strong>必须</strong>实现这个接口中所有的成员<br>可以将接口理解为一种变相的继承，接口中的方法需要在类中进行使用，但不是重写</p>
<p>使用接口是为了多态。<br>接口不能被实例化。也就是说，接口不能new(不能创建对象)</p>
<p>接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为public,不能修改。（默认为public）</p>
<p>接口中的成员不能有任何实现（“光说不做”，只是定义了一组未实现的成员）。</p>
<p>接口中只能有方法、属性、索引器、事件，不能有“字段”和构造函数。</p>
<p>接口与接口之间可以继承，并且可以多继承。</p>
<p>接口并不能去继承一个类，而类可以继承接口  （接口只能继承于接口，而类既可以继承接口，也可以继承类）</p>
<p>实现接口的子类必须实现该接口的全部成员。</p>
<p>一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA,那么语法上A必须写在IA的前面。</p>
<p>class MyClass:A,IA{}，因为类是单继承的。</p>
<p>类中默认的访问修饰符是private</p>
<p>显示实现接口的目的：解决方法的重名问题<br>什么时候显示的去实现接口：<br>当继承的借口中的方法和参数一摸一样的时候，要是用显示的实现接口</p>
<p>当一个抽象类实现接口的时候，需要子类去实现接口。</p>
<h1 id="第十四天"><a href="#第十四天" class="headerlink" title="第十四天"></a>第十四天</h1><p>winform应用程序是一种智能客户端技术，我们可以使用winform应用程序<br>帮助我们获得信息或者传输信息等。</p>
<p>属性<br>Name：在后台要获得前台的控件对象，需要使用Name属性。<br>visible：指示一个控件是否可见。<br>Enabled：指示一个控件是否可用。</p>
<p>事件：发生一件事情。<br>注册事件：双击控件注册的都是控件默认被选中的那个事件。<br>触发事件:</p>
<p>在Main函数当中创建的窗体对象，我们称之为这个窗体应用程序的主窗体。<br>也就意味着，当你将主窗体关闭后，整个应用程序都关闭了。</p>
<p>TextBox控件<br>WordWrap:指示文本框是否换行。<br>PasswordChar：让文本框显示一个单一的字符，就是你输入任何一个字符，都会转变为这个字符，类似于隐藏的密码<br>ScollBars：是否显示滚动条<br>事件：TextChanged 当文本框中的内容发生改变的时候触发这个事件。</p>
<p>跑马灯练习<br>abcde<br>bcdea<br>string str&#x3D;”abcde”;<br>        str&#x3D;str.Substring(1)+str.Substring(0,1);</p>
<p>cdeab<br>deabc<br>eabcd<br>abcde</p>
<p><strong>Timer</strong><br>在指定的时间间隔内做一件指定的事情。</p>
<p>简单记事儿本应用程序<br>1、在程序加载的时候，取消文本框的自动换行，以及让两个按钮和文本框隐藏<br>2、点击登陆，判断是否登陆成功<br>3、自动换行功能<br>4、保存文本到一个指定目录下。</p>
<p>.Focus();设置焦点</p>
<p><strong>单选和多选</strong><br>checked：指示这个控件是否处于选中状态。</p>
<p>默认情况下，在一个窗体中，所有的单选按钮只允许选中一个，可以使用groupbox进行分组。</p>
<p><strong>MDI窗体的设计</strong><br>1、首先确定一个父窗体。 将窗体属性IsMdiContainer设置为true。<br>2、创建子窗体，并且设置他们的父窗体。<br>Form2 frm2 &#x3D; new Form2();<br>frm2.MdiParent &#x3D; this<br>frm2.Show();</p>
<p>子窗体排列：LayoutMdi(枚举)</p>
<h1 id="第十五天"><a href="#第十五天" class="headerlink" title="第十五天"></a>第十五天</h1><p><strong>Directory 类</strong> ：操作文件夹<br>CreateDirectory 创建文件夹<br>Delete  删除文件夹<br>Move  剪切文件夹<br>Exist  判断是否存在<br>GetFiles 获得指定的目录下所有文件的全路径<br>GetDirectory 获得指定目录下所有文件夹的全路径</p>
<p>WebBrowser浏览器控件<br>url</p>
<p>ComboBox下拉框控件<br>DropDownStyle：控制下拉框的外观样式<br>名字：cbo+….<br>案例：日期选择器</p>
<p><strong>石头剪刀布思想</strong></p>
<p>石头 1   剪刀 2 布  3<br>玩家赢了：  1 2&#x3D;-1   2 3&#x3D;-1  3  1&#x3D;2<br>平手：   相减 &#x3D;0<br>另外一种情况 ：电脑赢了</p>
<p>进程<br>我们可以把计算机中每一个运行的应用程序都当做是一个进程。<br>而一个进程又是由多个线程组成的。</p>
<p>单线程给我们带来的问题<br>我们创建的线程都是前台线程，只有所有的前台线程全部结束后，程序才会结束。但是后台线程会在前台线程结束后自动结束。</p>
<p>在.Net下，是不允许跨线程的访问。<br>&#x2F;&#x2F;取消跨线程的检查Control.CheckForIllegalCrossThreadCalls &#x3D; false;</p>
<p>th.Start 告诉CPU准备就绪可以使用，有CPU来确定何时使用。<br>th.About 终止线程<br>Thread.sleep(时间) 可以使得当前线程引用</p>
<p>一个进程包含多个线程</p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>两个协议：TCP、UDP</p>
<p>TCP：传输更加安全、稳定，但是效率低 三次握手	必须有服务器</p>
<p>第一次：客户端向服务器发送请求</p>
<p>第二次：服务器向客户端回应请求</p>
<p>第三次：客户端向服务器再次发送请求</p>
<p>UDP：快速、效率高，但是不稳定，容易发生数据丢失</p>
<p>服务端：</p>
<p>1、创建一个负责监听的socket</p>
<p>2、创建IP地址和端口号对象</p>
<p>3、让负责监听的socket绑定IP地址跟端口号</p>
<p>4、设置监听队列（在某一个时间点，能够连入服务端的最大客户端数量）</p>
<p>5、负责监听的socket来接受客户端的连接请求  创建跟客户端通信的socket		—监听会一直占用线程</p>
<p>线程执行的方法，如果有参数，那么这个参数的类型必须是object，并且传入的参数需要在start方法中传进去。</p>
<p>涉及到网络连接的，全部try起来，但是catch中不给任何的内容。因为涉及到网络连接这部分内容的时候，经常会出现异常。</p>
<h1 id="基础复习"><a href="#基础复习" class="headerlink" title="基础复习"></a>基础复习</h1><p><strong>静态与非静态</strong></p>
<p><img src="C:\Users\80741\AppData\Roaming\Typora\typora-user-images\image-20220809192125662.png" alt="image-20220809192125662"></p>
<p><strong>注释符</strong><br>单行注释 &#x2F;&#x2F; 注释单行代码<br>多行注释  &#x2F;<em>要注释内容</em>&#x2F;<br>文档注释  &#x2F;&#x2F;&#x2F; 注释类和方法</p>
<p><strong>命名规范</strong><br>Camel骆驼命名规范:要求首单词的首字母小写，其余单词首字母大写，变量、字段<br>int age  string name  char gender  string highSchool<br>int _chinese  字段</p>
<p>Pascal:类或者方法 GetMax  GetSum   </p>
<p><strong>面向对象的复习</strong>		面向对象：增强了程序的可拓展性<br>三大特性：封装、继承、多态<br>–字段：存储数据，访问修饰符应该设置为private私有的<br>–属性：保护字段，对字段的取值和赋值进行限定。</p>
<p>–new关键字：<br>一：创建对象<br>1、在堆中开辟空间<br>2、在开辟的空间中创建对象<br>3、调用对象的构造函数（为对象初始化）<br>二：在子类中影藏从父类那里继承过来的成员</p>
<p>–this关键字：1、代表当前类的对象  2、调用自己的构造函数<br>–构造函数：初始化对象，当创建对象的时候，会调用构造函数。<br>对字段的保护方法：<br>a.get()<br>b.set()<br>c.构造函数</p>
<p>***return：<br>a.立即结束本次方法<br>a.在方法中返回要返回的值</p>
<p>base<br>1、显示的调用父类的构造函数<br>2、调用父类中的的重名方法：比如子类与父类中有一个同名函数，当子类的这个同名函数调用父类中的这个同名函数的时候是调用不到的，只能调用自己本身从而形成了递归；为了避免这种递归的出现，可以使用base.父类中的方法名来调用父类中的方法。</p>
<p><strong>继承</strong><br>解决代码的冗余，实现多态，增加了代码的扩展性，便于维护。<br>1、单根性<br>2、传递性<br>子类并没有继承父类的构造函数，而是会默认调用父类那个无参数的构造函数。<br>如果一个子类继承了一个父类，那么这个子类除了可以使用自己的成员外，还可以使用从父类那里继承过来的成员。但是父类永远都只能使用自己的成员，而不能使用子类的成员。子类之间也不能互相使用对方的成员。</p>
<p><strong>里氏转换</strong><br>1、子类可以赋值给父类<br>2、如果父类中装的是子类对象，那么可以将这个父类转换为子类对象。<br>3、as、is两个判断关键字</p>
<p><strong>多态</strong><br>1、虚方法  virtual<br>2、抽象类  abstract</p>
<p>静态与非静态<br>在一个类中，如果既有静态成员，也有非静态成员，则首先初始化静态成员；并且只初始化一次，不管创建多少个对象都只初始化一次；非静态成员，有多少个对象就初始化多少次。</p>
<p>在整个项目中，静态成员是资源共享的，静态成员只有在整个项目都结束的时候，才释放资源。</p>
<p><strong>访问修饰符</strong><br>public:公开的，公共的<br>private:私有的，只能在当前类的内部访问，类中成员们，如果不加访问修饰符，默认就是private<br>procteced：受保护的，可以在当前类的内部访问，也可以在该类的子类中访问<br>internal：在当前项目中都可以访问。<br>protected internal：<br>能够修饰类的访问修饰符只有两个，internal和public</p>
<p><strong>常用的关键字</strong><br>this<br>1、当前类的对象<br>2、调用自己的构造函数（两个构造函数有重复赋值的地方）；有多个构造函数那么创建对象的时候就可以选择，不需要传入多的不需要的参数。</p>
<p>new<br>1、创建对象<br>2、隐藏父类的成员</p>
<p>virtual<br>标记一个方法是虚方法</p>
<p>abstract<br>抽象的</p>
<p>override<br>重写</p>
<p>interface<br>接口</p>
<p>partial<br>部分类</p>
<p>sealed<br>密封类：不允许被继承</p>
<p>return<br>1、在方法中返回要返回的值<br>2、立即结束本次方法</p>
<p>break<br>跳出当前循环</p>
<p>continue<br>结束本次循环，回到循环条件进行判断</p>
<p>static<br>静态的</p>
<p>struct<br>结构</p>
<p>enum<br>枚举</p>
<p>const<br>常量</p>
<p><strong>字符串</strong><br>1、字符串的不可变性<br>2、字符串可以看做是char类型的只读数组</p>
<p><strong>集合</strong><br>ArrayList<br>Hashtable<br>List<T><br>Dictionary&lt;TKey,TValue&gt;</p>
<p><strong>装箱或者拆箱</strong><br>装箱：就是将值类型转换为引用类型<br>拆箱:就是将引用类型转换为值类型。<br>值类型:bool int double char struct enum decimal<br>引用类型：string 数组 集合 interface object 自定义类<br>拆箱或者装箱的两种类型必须具有继承关系</p>
<p><strong>结构和类的区别</strong><br>1、类当中写了一个新的构造函数之后，默认的无参数的就被干掉了。<br>但是在结构中，写了一个新的构造函数之后，默认的那个无参数的还在。<br>2、在结构的构造函数当中，必须给所有的字段赋值，这样也就限制了结构中最多只能有两个构造函数，一个是默认的无参数的构造函数，一个是全参数的构造函数。<br>在类中，构造函数里，既可以给字段赋值，也可以给属性赋值，构造函数是可以重载的；<br>在结构中，只能够给字段赋值，并且我们需要给全部字段赋值，而不能选择地给字段赋值。</p>
<p>2、结构的new关键字只干了一件事儿，就是调用结构的构造函数。</p>
<p>3、结构不能继承于类，而类也不能继承于结构。<br>结构不具备面向对象的特征。<br>而类才是面向对象的产物。</p>
<p>4、如果不给结构创建对象的话，不允许调用结构中的非静态方法。</p>
<p>string[] str &#x3D; File.ReadAllLines(“全路径”，解码)；	可以得到文件中每一行的文本。</p>
<p>int.MinValue	int能表示的最小值<br>int.MaxValue	int能表示的最大值</p>
<p><strong>File类</strong></p>
<p>File &#x2F;&#x2F;操作文件，静态类，对文件整体操作。拷贝、删除、剪切等。<br>Directory &#x2F;&#x2F;操作目录（文件夹），静态类。<br>Path&#x2F;&#x2F;对文件或目录的路径进行操作（很方便）【字符串】<br>Stream&#x2F;&#x2F;文件流，抽象类。<br>FileStream&#x2F;&#x2F;文件流,MemoryStream(内存流),NetworkStream(网络流)<br>StreamReader &#x2F;&#x2F;快速读取文本文件<br>StreamWriter&#x2F;&#x2F;快速写入文本文件</p>
<p><strong>Path类</strong></p>
<p>File.ChangeExtension(string path, string extension)<br>修改文件的后缀，“修改”支持字符串层面的，没有真的给文件改名<br>File.Combine(string path1, string path2)<br>将两个路径合成一个路径，比用+好，可以方便解决不加斜线的问题，自动处理路径分隔符的问题<br>string s &#x3D; Path.Combine(@”c:\temp”,”a.jpg”)<br>string GetDirectoryName(string path)<br>得到文件的路径名。<br>string GetExtension(string path) 得到文件的扩展名<br>string GetFileName(string path) 得到文件路径的文件名部分<br>string GetFileNameWithoutExtension(string path) 得到去除扩展名的文件名<br>string GetFullPath(string path) 得到文件的全路径。可以根据相对路径获得绝对路径。</p>
<p>void AppendAllText(string path, string contents)，将文本contents附加到文件path中<br>bool Exists(string path)判断文件path是否存在<br>string[] ReadAllLines(string path) 读取文本文件到字符串数组中，需要操作每一行数据的时候使用这个。<br>string ReadAllText(string path) 读取文本文件到字符串中<br>void WriteAllText(string path, string contents)将文本contents保存到文件path中，会覆盖旧内容。<br>WriteAllLines(string path,string[] contents)，将字符串数组逐行保存到文件path中，会覆盖旧内容。</p>
<p><strong>序列化步骤</strong><br>第一步：创建一个文件流<br>第二步：创建一个二进制序列化器：<br>BinaryFormatter bf&#x3D;new BinaryFormatter()<br>第三步：bf.Serialize(stream,对象)</p>
<p><strong>反序列化步骤：</strong><br>第一步：创建一个文件流<br>第二步：创建一个二进制序列化器：<br>BinaryFormatter bf&#x3D;new BinaryFormatter()<br>第三步：object obj &#x3D; bf.Deserialize(stream,对象)</p>
<h1 id="第二十二天"><a href="#第二十二天" class="headerlink" title="第二十二天"></a>第二十二天</h1><p><strong>单例模式</strong></p>
<p>只能创建一个对象</p>
<p><img src="C:\Users\80741\AppData\Roaming\Typora\typora-user-images\image-20220809185430520.png" alt="image-20220809185430520"></p>
<p>首先这个类得是私有类，不能够创建对象；</p>
<p>然后通过构造这个类的静态方法，从而可以在类中创建对象；</p>
<p>通过一个该类类型的的字段，初始赋值为null，外界调用方法后赋值为刚刚创建的对象，以后每次调用的都是这个对象，从而实现单例模式。</p>
<p><strong>XML</strong>可扩展的标记语言（相当于一个小型的数据库）</p>
<p>XML：存储数据</p>
<p>注意：XML是严格区分大小写的，XML标签是成对出现的 </p>
<p>通过代码创建XML文档：</p>
<p>1.引用命名空间：System.Xml；</p>
<p>2.创建XML文档对象：XmlDocument doc &#x3D; new ……；</p>
<p>3.创建第一行的描述信息，并且添加到doc中：XmlDeclaration dec &#x3D; doc.CreateXmlDeclaration(按提示填写)；</p>
<p>doc.AppendChild(dec);</p>
<p>doc.Save(“文档命名”)；</p>
<p>报错：文档必须有根节点，且根节点唯一；</p>
<p>4.给文档创建根节点：XmlElement books &#x3D; doc.CreateElement(“Books”)；再将根节点添加到文档中：doc.AppendChild(books);</p>
<p>5.给Books创建子节点：XmlElement book1 &#x3D; doc.CreateElement(“Book”)；将这个子节点添加到文档中:books.AppendChild(book1)；</p>
<p>6.给book1创建子节点：XmlElement name1 &#x3D; doc.CreateElement(“Name”)；将这个子节点添加到文档中：book1.AppendChild(name1)；标签内部添加文本：name1.InnerText &#x3D; “文本”；</p>
<p>注：InnerXml可以添加标签</p>
<p>7.给节点添加属性：orderItem1.SetAttribute(“Name”,”雨伞”)；orderItem1.SetAttribute(“Price”,”10”)；</p>
<p>将这个属性添加到文档中：item.AppendChild(orderItem1)；</p>
<p><strong>追加XML</strong></p>
<p>如果文件存在，先加载，然后获得文件的根节点</p>
<p>如果文件不存在，先创建第一行，然后在创建根节点</p>
<p>读取<strong>XML</strong></p>
<p>先加载，然后获得文件的根节点，获取子节点，返回子节点的集合（用foreach,XmlNode）</p>
<p>—具体语法看一下例程</p>
<p><strong>委托</strong></p>
<p>使用委托的原因：将一个方法作为参数传递给另一个方法；那么传入的方法就是委托类型的</p>
<p>概念：声明一个委托类型，委托所指向的函数必须跟委托有相同的签名；委托写在命名空间里面；</p>
<p>关键字：delegate</p>
<p><strong>匿名函数</strong></p>
<p>当这个方法就执行一次的时候，可以使用匿名函数</p>
<p><strong>lamda表达式</strong></p>
<p>{参数}&#x3D;&gt;{return 返回值}</p>
<p>n &#x3D;&gt; n &gt; 4   是一种缩写</p>
<p><strong>委托可以进行窗体传值</strong></p>
<p><strong>多播委托</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/02/13/MySQL%E7%AC%94%E8%AE%B0/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%A4%A9"><span class="nav-number">1.</span> <span class="nav-text">第一天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%A4%A9"><span class="nav-number">2.</span> <span class="nav-text">第二天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E5%A4%A9"><span class="nav-number">3.</span> <span class="nav-text">第三天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E5%A4%A9"><span class="nav-number">4.</span> <span class="nav-text">第四天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E5%A4%A9"><span class="nav-number">5.</span> <span class="nav-text">第五天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E5%A4%A9"><span class="nav-number">6.</span> <span class="nav-text">第六天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E5%A4%A9"><span class="nav-number">7.</span> <span class="nav-text">第七天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E5%A4%A9"><span class="nav-number">8.</span> <span class="nav-text">第八天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E5%A4%A9%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">第九天（面向对象）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%A4%A9"><span class="nav-number">10.</span> <span class="nav-text">第十天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9"><span class="nav-number">11.</span> <span class="nav-text">第十一天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9"><span class="nav-number">12.</span> <span class="nav-text">第十二天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9"><span class="nav-number">13.</span> <span class="nav-text">第十三天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9"><span class="nav-number">14.</span> <span class="nav-text">第十四天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9"><span class="nav-number">15.</span> <span class="nav-text">第十五天</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Socket"><span class="nav-number">16.</span> <span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0"><span class="nav-number">17.</span> <span class="nav-text">基础复习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9"><span class="nav-number">18.</span> <span class="nav-text">第二十二天</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龙Sir</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

